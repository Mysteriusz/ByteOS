#include "ByteOS.h"

#define MAX_PAGE_SECTIONS 0x64 // 100 Sections
#define PAGE_SIZE 0x1000 // 4 KiB RAM
#define MAX_PAGES 0x400000 // 16 GiB RAM
#define PAGES_PER_GROUP 0x08 // 8 Pages
#define MAX_PAGE_GROUPS (MAX_PAGES / PAGES_PER_GROUP) // 524,288 Groups

typedef BOOLEAN BT_MEMORY_PAGE_ALLOCATION;
#define PAGE_FREE 0
#define PAGE_ALLOCATED 1
#define BLOCK_FREE 0
#define BLOCK_ALLOCATED 1

typedef UINT8 BT_MEMORY_PAGE_FLAGS;
#define BT_MEMORY_READ 0x01
#define BT_MEMORY_WRITE 0x02
#define BT_MEMORY_EXECUTE 0x04
#define BT_MEMORY_USER 0x08
#define BT_MEMORY_KERNEL 0x10

#define BT_MEMORY_RW (BT_MEMORY_READ | BT_MEMORY_WRITE)
#define BT_MEMORY_RWX (BT_MEMORY_READ | BT_MEMORY_WRITE | BT_MEMORY_EXECUTE)

#define BT_MEMORY_USER_RW (BT_MEMORY_USER | BT_MEMORY_RW)
#define BT_MEMORY_KERNEL_RW (BT_MEMORY_KERNEL | BT_MEMORY_RW)

#define BT_MEMORY_USER_RWX (BT_MEMORY_USER | BT_MEMORY_RWX)
#define BT_MEMORY_KERNEL_RWX (BT_MEMORY_KERNEL | BT_MEMORY_RWX)

typedef struct MEMORY_SECTION{
    PHYSICAL_ADDRESS start;
    PHYSICAL_ADDRESS end;
} MEMORY_SECTION;

typedef struct MEMORY_PAGE{
    BT_MEMORY_PAGE_ALLOCATION allocation;
    BT_MEMORY_PAGE_FLAGS flags;
    UINT16 attributes;
    PHYSICAL_ADDRESS physicalAddress;
    UINT32 index;
} MEMORY_PAGE;


#define POOL_BLOCKS_PER_MAP 0x08 // 8 Bits
#define MAX_MAP_SIZE 32 // 32 Maps

typedef struct MEMORY_PAGE_POOL_HEADER MEMORY_PAGE_POOL_HEADER;
typedef struct MEMORY_PAGE_POOL_HEADER{
    MEMORY_PAGE_POOL_HEADER *next;
    UINT16 blockSize;
    UINT8 poolMap[MAX_MAP_SIZE];
} MEMORY_PAGE_POOL_HEADER;

#define POOL_TINY_BLOCK_SIZE 0x10 // 16 Bytes
#define POOL_SMALL_BLOCK_SIZE 0x20 // 32 Bytes
#define POOL_MEDIUM_BLOCK_SIZE 0x40 // 64 Bytes
#define POOL_BIG_BLOCK_SIZE 0x80 // 128 Bytes
#define POOL_HUGE_BLOCK_SIZE 0x100 // 256 Bytes

#define POOL_BLOCK_SIZE(bytes) \
( \
    ((UINT32)bytes) <= POOL_TINY_BLOCK_SIZE ? POOL_TINY_BLOCK_SIZE : \
    ((UINT32)bytes) <= POOL_SMALL_BLOCK_SIZE ? POOL_SMALL_BLOCK_SIZE : \
    ((UINT32)bytes) <= POOL_MEDIUM_BLOCK_SIZE ? POOL_MEDIUM_BLOCK_SIZE : \
    ((UINT32)bytes) <= POOL_BIG_BLOCK_SIZE ? POOL_BIG_BLOCK_SIZE : \
    ((UINT32)bytes) <= POOL_HUGE_BLOCK_SIZE ? POOL_HUGE_BLOCK_SIZE : \
    ((UINT32)bytes) & ~0x0f \
)
#define POOL_BLOCK_COUNT(blockSize) ((PAGE_SIZE - sizeof(MEMORY_PAGE_POOL_HEADER)) / (UINT32)blockSize)

#define POOL_TINY_BLOCK_COUNT (POOL_BLOCK_COUNT(POOL_TINY_BLOCK_SIZE))
#define POOL_SMALL_BLOCK_COUNT (POOL_BLOCK_COUNT(POOL_SMALL_BLOCK_SIZE))
#define POOL_MEDIUM_BLOCK_COUNT (POOL_BLOCK_COUNT(POOL_MEDIUM_BLOCK_SIZE))
#define POOL_BIG_BLOCK_COUNT (POOL_BLOCK_COUNT(POOL_BIG_BLOCK_SIZE))
#define POOL_HUGE_BLOCK_COUNT (POOL_BLOCK_COUNT(POOL_HUGE_BLOCK_SIZE))

// ==================================== |
//               PHYSICAL               |
// ==================================== |

BT_STATUS ByteAPI InitializePhysicalMemory(KERNEL_MEMORY_MAP *memMap);
BT_STATUS ByteAPI InitializePhysicalPages(KERNEL_MEMORY_MAP *memMap);
BT_STATUS ByteAPI InitializePhysicalPool();

BT_STATUS ByteAPI AllocPhysicalPages(IN OUT VOID **buffer, IN OUT UINTN *size, IN BT_MEMORY_PAGE_FLAGS flags);
BT_STATUS ByteAPI FreePhysicalPages(IN VOID *buffer, IN OUT UINTN *size);
BT_STATUS ByteAPI ClearPhysicalPages(IN VOID *address, IN UINTN size);
MEMORY_PAGE ByteAPI GetPhysicalPage(UINT32 index);

BT_STATUS ByteAPI AllocPhysicalPool(IN OUT VOID **buffer, IN OUT UINTN *size, IN BT_MEMORY_PAGE_FLAGS flags);
BT_STATUS ByteAPI FreePhysicalPool(IN VOID *buffer, IN OUT UINTN *size);

// ==================================== |
//           PHYSICAL HELPERS           |
// ==================================== |

PHYSICAL_ADDRESS PAGE_ADDRESS_FROM_INDEX(UINT32 index);
UINT32 PAGE_INDEX_FROM_ADDRESS(PHYSICAL_ADDRESS address);
PHYSICAL_ADDRESS PAGE_SECTION_OFFSET(PHYSICAL_ADDRESS pageAddress, UINT32 sectionIndex);
UINT32 PAGE_SECTION_INDEX(PHYSICAL_ADDRESS pageAddress);
VOID PAGE_UPDATE_CLOSEST();

// ==================================== |
//            PHYSICAL DEBUG            |
// ==================================== |

VOID DEBUG_ALLOC(UINT32 index);
VOID DEBUG_FREE(UINT32 index);
MEMORY_SECTION DEBUG_SECTION(UINT32 index);
UINT32 DEBUG_SECTION_INDEX(PHYSICAL_ADDRESS address);
PHYSICAL_ADDRESS DEBUG_SECTION_OFFSET(PHYSICAL_ADDRESS address, UINT32 index);
UINT32 DEBUG_INDEX_FROM_ADDRESS(PHYSICAL_ADDRESS address);
PHYSICAL_ADDRESS DEBUG_ADDRESS_FROM_INDEX(UINT32 index);
PHYSICAL_ADDRESS DEBUG_CLOSEST();
MEMORY_PAGE_POOL_HEADER *DEBUG_GET_FREE_POOLS();
